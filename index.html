<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Bouncing Ball Platformer</title>
    <script src="https://unpkg.com/@farcade/game-sdk@latest/dist/index.min.js"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        background: #222;
        font-family: Arial, sans-serif;
      }
      #gameCanvas {
        background: #87ceeb;
        border: 2px solid #000;
      }
      #ui {
        position: absolute;
        color: white;
        padding: 10px;
        pointer-events: none;
      }
      .screen {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        text-align: center;
        padding: 20px;
        width: 600px;
        display: none;
      }
      .touch-controls {
        position: absolute;
        bottom: 0;
        width: 100%;
        display: none;
        justify-content: space-between;
        padding: 10px;
      }
      .touch-btn {
        width: 80px;
        height: 80px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 10px;
        touch-action: none;
      }
      @media (max-width: 768px) {
        .touch-controls {
          display: flex;
        }
      }
    </style>
  </head>
  <body>
    <div id="ui">
      Score: <span id="score">0</span> | Lives: <span id="lives">3</span>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="startScreen" class="screen">
      <h1>Bouncing Ball Platformer</h1>
      <p>Controls:</p>
      <p>Move: ←/→ or A/D</p>
      <p>Jump: Space or W (Double Jump Available)</p>
      <p>Pause: P</p>
      <p>Avoid the bouncing balls!</p>
      <p>Press Space to Start</p>
    </div>
    <div id="gameOverScreen" class="screen">
      <h1>Game Over</h1>
      <p>Final Score: <span id="finalScore">0</span></p>
      <p>Press Space to Restart</p>
    </div>
    <div class="touch-controls">
      <div id="touchLeft" class="touch-btn"></div>
      <div id="touchRight" class="touch-btn"></div>
      <div id="touchJump" class="touch-btn"></div>
    </div>

    <script>
      const canvas = document.getElementById('gameCanvas')
      const ctx = canvas.getContext('2d')
      const startScreen = document.getElementById('startScreen')
      const gameOverScreen = document.getElementById('gameOverScreen')
      const scoreDisplay = document.getElementById('score')
      const livesDisplay = document.getElementById('lives')
      const finalScoreDisplay = document.getElementById('finalScore')

      canvas.width = 800
      canvas.height = 600

      const GRAVITY = 0.5
      const FRICTION = 0.8
      let gameState = 'start'
      let lastTime = 0
      let spawnTimer = 0
      let nextSpawnDelay = 5 // Start with 5-second delay

      class Player {
        constructor() {
          this.width = 30
          this.height = 40
          this.x = 100
          this.y = canvas.height - this.height
          this.dx = 0
          this.dy = 0
          this.speed = 5
          this.jumpForce = -12
          this.jumps = 2
          this.maxJumps = 2
          this.onGround = false
          this.lives = 3
        }

        draw() {
          ctx.fillStyle = this.alive ? '#00FF00' : '#FF0000'
          ctx.fillRect(this.x, this.y, this.width, this.height)
        }

        update(deltaTime) {
          this.dy += GRAVITY
          this.y += this.dy
          this.x += this.dx

          this.dx *= FRICTION

          if (this.x < 0) this.x = 0
          if (this.x + this.width > canvas.width)
            this.x = canvas.width - this.width

          platforms.forEach((platform) => {
            if (this.isColliding(platform) && this.dy > 0) {
              this.y = platform.y - this.height
              this.dy = 0
              this.onGround = true
              this.jumps = this.maxJumps
            }
          })

          if (this.y + this.height > canvas.height) {
            this.y = canvas.height - this.height
            this.dy = 0
            this.onGround = true
            this.jumps = this.maxJumps
          }
        }

        jump() {
          if (this.jumps > 0) {
            this.dy = this.jumpForce
            this.jumps--
            this.onGround = false
          }
        }

        isColliding(obj) {
          return (
            this.x < obj.x + obj.width &&
            this.x + this.width > obj.x &&
            this.y + this.height > obj.y &&
            this.y + this.height < obj.y + obj.height + 5
          )
        }
      }

      class Ball {
        constructor(x, y, radius, dx, dy) {
          this.x = x
          this.y = y
          this.radius = radius
          this.dx = dx
          this.dy = dy
          this.color = `hsl(${Math.random() * 360}, 100%, 50%)`
          this.lifetime = 20 // Ball lasts 20 seconds
        }

        draw() {
          ctx.beginPath()
          ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2)
          ctx.fillStyle = this.color
          ctx.fill()
          ctx.closePath()
        }

        update(deltaTime) {
          this.dy += GRAVITY
          this.x += this.dx
          this.y += this.dy
          this.lifetime -= deltaTime / 60 // Adjusted for 60 FPS normalization

          if (this.x - this.radius < 0 || this.x + this.radius > canvas.width) {
            this.dx = -this.dx * 0.9
            this.x = Math.max(
              this.radius,
              Math.min(canvas.width - this.radius, this.x)
            )
          }

          if (this.y + this.radius > canvas.height) {
            this.y = canvas.height - this.radius
            this.dy = -this.dy * 0.9
          }

          platforms.forEach((platform) => {
            if (this.isColliding(platform) && this.dy > 0) {
              this.y = platform.y - this.radius
              this.dy = -this.dy * 0.9
            }
          })
        }

        isColliding(obj) {
          const dx = this.x - (obj.x + obj.width / 2)
          const dy = this.y - (obj.y + obj.height / 2)
          const distance = Math.sqrt(dx * dx + dy * dy)
          return distance < this.radius + Math.max(obj.width, obj.height) / 2
        }
      }

      class Platform {
        constructor(x, y, width, height) {
          this.x = x
          this.y = y
          this.width = width
          this.height = height
        }

        draw() {
          ctx.fillStyle = '#666'
          ctx.fillRect(this.x, this.y, this.width, this.height)
        }
      }

      let player = new Player()
      let balls = []
      let platforms = [
        new Platform(200, 450, 150, 20),
        new Platform(450, 350, 150, 20),
        new Platform(150, 250, 150, 20),
        new Platform(500, 150, 150, 20),
      ]
      let score = 0
      let gameTime = 0

      const keys = {}
      document.addEventListener('keydown', (e) => {
        keys[e.key] = true
        if (e.key === ' ' && gameState === 'start') startGame()
        if (e.key === ' ' && gameState === 'gameover') resetGame()
        if (e.key === 'p' && gameState === 'playing')
          gameState = gameState === 'paused' ? 'playing' : 'paused'
      })
      document.addEventListener('keyup', (e) => (keys[e.key] = false))

      const touchLeft = document.getElementById('touchLeft')
      const touchRight = document.getElementById('touchRight')
      const touchJump = document.getElementById('touchJump')

      touchLeft.addEventListener('touchstart', () => (keys['ArrowLeft'] = true))
      touchLeft.addEventListener('touchend', () => (keys['ArrowLeft'] = false))
      touchRight.addEventListener(
        'touchstart',
        () => (keys['ArrowRight'] = true)
      )
      touchRight.addEventListener(
        'touchend',
        () => (keys['ArrowRight'] = false)
      )
      touchJump.addEventListener('touchstart', (e) => {
        e.preventDefault()
        player.jump()
      })

      function startGame() {
        gameState = 'playing'
        startScreen.style.display = 'none'
        resetGame()
      }

      function resetGame() {
        player = new Player()
        balls = []
        score = 0
        gameTime = 0
        spawnTimer = 0
        nextSpawnDelay = 5 // Start with 5-second delay
        spawnBall() // Spawn first ball
        gameState = 'playing'
        gameOverScreen.style.display = 'none'
      }

      function spawnBall() {
        const radius = Math.random() * 20 + 10
        const x = Math.random() * (canvas.width - radius * 2) + radius
        const dx = (Math.random() - 0.5) * 8
        const dy = -(Math.random() * 5 + 5)
        balls.push(new Ball(x, 50, radius, dx, dy))
      }

      function update(deltaTime) {
        if (gameState !== 'playing') return

        // Player movement
        if (keys['ArrowLeft'] || keys['a']) player.dx = -player.speed
        if (keys['ArrowRight'] || keys['d']) player.dx = player.speed
        if ((keys[' '] || keys['w']) && !keys['spacePressed']) {
          player.jump()
          keys['spacePressed'] = true
        }
        if (!keys[' ']) keys['spacePressed'] = false

        player.update(deltaTime)

        // Ball updates and collision
        balls.forEach((ball, index) => {
          ball.update(deltaTime)
          if (ball.isColliding(player)) {
            player.lives--
            if (player.lives <= 0) {
              gameState = 'gameover'
              gameOverScreen.style.display = 'block'
              finalScoreDisplay.textContent = Math.floor(score)
            }
          }
          // Remove balls that have exceeded their lifetime
          if (ball.lifetime <= 0) {
            balls.splice(index, 1)
          }
        })

        // Game progression
        gameTime += deltaTime
        score += deltaTime
        spawnTimer += deltaTime / 60 // Adjusted for 60 FPS normalization

        // Spawn new balls with decreasing delay (increasing spawn rate), up to 5 balls
        if (spawnTimer >= nextSpawnDelay && balls.length < 5) {
          spawnBall()
          spawnTimer = 0
          // Decrease spawn delay over time, minimum 1 second
          nextSpawnDelay = Math.max(1, nextSpawnDelay - gameTime / 60 / 60) // Reduces by 1 second every minute
        }

        // UI updates
        scoreDisplay.textContent = Math.floor(score)
        livesDisplay.textContent = player.lives
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height)

        platforms.forEach((platform) => platform.draw())
        player.draw()
        balls.forEach((ball) => ball.draw())
      }

      function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTime) / 16.67 // Normalize to 60 FPS
        lastTime = timestamp

        update(deltaTime)
        draw()

        requestAnimationFrame(gameLoop)
      }

      startScreen.style.display = 'block'
      requestAnimationFrame(gameLoop)
    </script>
  </body>
</html>
